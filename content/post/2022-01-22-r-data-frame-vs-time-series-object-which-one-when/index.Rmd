---
title: 'R Time Series Object vs Data Frames: Strengths and Limitations?'
author: Package Build
date: '2022-01-22'
slug: []
categories:
  - R
tags:
  - dataviz
description: 'Exploration of time series objects strengths and limitations relative to data frames in R.'
thumbnail: ''
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message=FALSE,
                      warning=FALSE,
                      fig.height=4,
                      fig.width=8)
options(scipen = 99)
options(digits=3)

library(tidyverse)
library(xts)
library(dygraphs)
library(quantmod)
library(here)
library(lubridate)
```

Data frames are one of the fundamental building blocks of data analysis done in R. In some cases, though, **time series** objects offer more flexibility and other advantages when analyzing time-based data.

So when to choose time series rather data frames?

### Time Series Essentials

**xts** is the main R package for working with time series. It builds on **zoo**, the original pkg for handling time series in R.   **Datacamp** has an excellent [xts Cheat Sheet](http://datacamp-community-prod.s3.amazonaws.com/72771032-0653-4d87-a798-4a83879e99c8) and very helpful [supplementary info.](https://www.datacamp.com/community/blog/r-xts-cheat-sheet)  

For deeper, more sophisticated dive, the highly valuable - yet free! - ['Little Book of R for Time Series'](https://a-little-book-of-r-for-time-series.readthedocs.io/en/latest/index.html) by Dr. Avril Coghlan is  available online in pdf form. 

So I'm just going to hit some highlights with examples here.

#### Get a Time Series Object

Some types of data are already identified as being time series. For example, the quantmod package fetches stock market data as time series automatically:

```{r}
## use quantmod pkg to get some stock prices as time series
price <- getSymbols(Symbols='EA', from="2020-01-01", to=Sys.Date(), auto.assign=FALSE)
head(price)

```

A key characteristic of time series is that dates are row numbers rather than being in a date column, as they would be in typical data frame. Looking at the structure of the xts object, we can see it is different from a data frame.

```{r}
str(price)
```

A data frame structure for comparison, also data based on dates:

#### Convert xts to data frame

Fairly straightforward to convert an xts object to data frame:

```{r}
price_df <- as.data.frame(price)
## add Date field based on index (row names) of xts object
price_df$Date <- index(price)
## set data frame row names to numbers instead of dates
rownames(price_df) <- seq(1:nrow(price))
## reorder columns to put Date first
price_df <- price_df %>% select(Date, 1:ncol(price_df)-1)
## check out structure using glimpse, as is the fashion of the times
glimpse(price_df)
```

Data frame is basically a straight-up table, whereas the xts object has other structural features. This has a variety of implications for working with the data, and some specific benefits in terms of the time aspect. A few of the main ones, at least from my perspective:

* visualization: a number of visualization options are designed to work with time series. 
* periodicity: can easily change from granular periods, such as daily, to aggregated periods
* period calculations: counting number of periods in the data (months, quarters, years)
* date range selection/subsetting
* forecasting

* types of calculations easily available
* selecting date ranges
* aggregating into periods like weekly, monthly, quarterly, annually

* charting

#### Periodicity Manipulation

Change the period granularity to less granular:

```{r}
head(to.weekly(price)[,1:5])
head(to.monthly(price)[,1:5])
head(to.yearly(price)[,1:5])
```

#### Period Counts

```{r}
price_nw <- nweeks(price)
price_nm <- nmonths(price)
price_ny <- nyears(price)
```

The price data covers:

* `nrow(price)` days
* `price_nw` weeks
* `price_nm` months
* `price_ny` years (or *portions* thereof)

```{r}
## get earliest date
st_date <- start(price)
## get last date
end_date <- end(price)
```

* Start: `r st_date`
* End: `r end_date`

#### Selecting/Subsetting

Time series objects make it easy to slice the data by date ranges. This is an area where time series *really* shine compared to trying to do the same thing with a data frame.

* xts does a good job at interpreting date ranges based on minimal info.
* '/' is a key symbol for separating dates.
* date ranges are inclusive of references used.

Note that in the following examples based on stock market data, some dates are missing when markets were closed.

```{r}
## subset on a YEAR (showing head and tail to confirm data is 2021 only)
head(price["2021"])
tail(price["2021"])

## get data DURING selected month
price["2020-02"]

## get data FROM start of a year to END OF SPECIFIC MONTH
price_jf <- price["2021/2021-02"]
head(price_jf, 4)
tail(price_jf, 3)

## get everything BEFORE specified date (based on what is avaliable)
price["/2020-01-06"]

## get everything BETWEEN two dates
price["2021-06-01/2021-06-04"]

## get everything AFTER specified date
price["2022-01-18/"]
```

#### Period Calculations

* simple arithmetic between two dates is not as straightforward as might be expected, but still easily doable.

```{r}
## subtraction of a given metric between two dates
as.numeric(price$EA.Close["2022-01-21"])-as.numeric(price$EA.Close["2022-01-18"])

## subtraction of one metric from another on same date
price$EA.Close["2022-01-18"]-price$EA.Open["2022-01-18"]
```

* lag.xts is versatile for lag calculations.

```{r}
## default is one period
head(price-lag.xts(price))
## set k for longer lag - this example starting at a date beyond the lag, so no NAs
head(price["2020-01-13/"]-lag.xts(price, k=7))

## works for individual column
price$EA.Close["2022-01-18/"]-lag.xts(price$EA.Close, k=2)
```

* diff for calculating differences, based on combination of lag and difference order.

```{r}
head(diff(price, lag=1, differences=1))
head(diff(price, lag=1, differences=2))
```

### Visualization

Time series objects offer some different visualization opportunities than data frames. Below are a couple of options.

#### Plot.ts

You can do a quick, simple plot with plot.ts(). Note that in this case the x-axis is the numerical index of the data point, and doesn't show the date. 

```{r}
plot.ts(price$EA.Close)
```

#### Dygraphs

The dygraphs package offers flexibility and interactivity for time series.

* easily show multiple metrics at once.
* scroll over to see details.
* select chart area to zoom in.

```{r}
dygraph(price[,1:4])
```


* subset for individual columns.
* easily add annotations for events.

```{r}
## use dyEvent to add annotations
graph <- dygraph(price$EA.Close)
graph <- dyEvent(graph, "2020-02-21","Start of Covid 19", labelLoc = 'top')
graph <- dyEvent(graph, "2021-06-10","New product announcements", labelLoc = 'top')
## print chart
graph
```


### Creating/Converting to a Time Series Object

#### ts objects

Some objects are identified as 'ts', and may be in a matrix. These can be converted to xts for manipulation.

* monthly air passenger data for 1949 - 1960.

```{r}
AirPassengers
```

* use as.xts to convert to xts.

```{r}
## convert ts to xts
air_xts <- as.xts(AirPassengers) ## ts object
## set metric column name
colnames(air_xts) <- 'passengers'
head(air_xts)
```

#### Data frame to xts

```{r}
## import time-based data in csv file. will import as data frame
price_df_im <- read_csv(here('static/src_data/price_df.csv'))
## convert data frame to xts object by specifying the date field to use for xts index.
price_xts <- xts(price_df_im, order.by=as.Date(price_df_im$Date))
```

#### Saving

No doubt there are more efficient/proper ways, but what works for me is to convert the time series to a data frame and save as .csv. Can always convert back to xts on import.

```{r}
## create data frame based on xts

## save as csv
write_csv(price_df, here('static/src_data/price_df.csv'))

## can re-import csv and convert to xts object as shown above.
```

### Forecasting

Time series objects are designed for forecasting exercises.

### Limitations

Times series objects are obviously a powerful way to work with time-based data. When doing statistical modeling or forecasting with time series, they are the go-to.

There are some cases where you may prefer to stick with data frames:

* **Export/Import**: data frames are easier to work with for importing and exporting. 
* **Multi-dimensional data**: time series work best when each row represents a distinct time. If you are dealing with multi-dimensional data, especially in tidy format, you may want to stick with data frame.
* **Visualization preferences**: if you are more comfortable with using ggplot2 (or other visualization tools geared toward data frames) a data frame may be preferable. Or if the document you are producing has ggplot2 charts, you may want to maintain standard presentation.
* **Forecasting needs**: if you are doing time series forecasting you will want to use a time series object. If you're not doing forecasting, there is less of a need.