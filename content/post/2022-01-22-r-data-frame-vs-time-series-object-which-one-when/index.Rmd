---
title: 'R Time Series Object vs Data Frames: Strengths and Limitations'
author: John Yuill
date: '2022-01-22'
categories:
  - R
tags:
  - dataviz
description: Exploration of time series objects strengths and limitations relative
  to data frames in R.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message=FALSE,
                      warning=FALSE,
                      fig.height=4,
                      fig.width=8)
options(scipen = 99)
options(digits=3)

library(tidyverse)
library(xts)
library(dygraphs)
library(quantmod)
library(here)
library(lubridate)
```

Data frames are a fundamental building block of data analysis done in R. In some cases, though, **time series** objects offer more flexibility and other advantages when analyzing time-based data. Any data set that is comprised of repeated measurements over time (hourly, daily, monthly, etc) is a good candidate: weekly website visits, monthly sales, daily stock prices, annual GDP, that kind of thing.

So what are these time series advantages? How do we leverage them? What limitations of time series objects are good to be aware of? Read on...

### Time Series Essentials

**xts** is the main R package for working with time series. It builds on **zoo**, the original pkg for handling time series in R.   **Datacamp** has an excellent [xts Cheat Sheet](http://datacamp-community-prod.s3.amazonaws.com/72771032-0653-4d87-a798-4a83879e99c8) and very helpful [supplementary info.](https://www.datacamp.com/community/blog/r-xts-cheat-sheet)  

For deeper, more sophisticated dive, the highly valuable - yet free! - ['Little Book of R for Time Series'](https://a-little-book-of-r-for-time-series.readthedocs.io/en/latest/index.html) by Dr. Avril Coghlan is  available online in pdf form. 

So I'm just going to hit some highlights with examples here.

#### Get a Time Series Object

At its most basic, a Time-Series object is a list or sometimes matrix of observations at regular time intervals.

Examples in built-in R data sets include:

* annual Nile river flows

```{r}
class(Nile)
str(Nile)
Nile
```

* monthly Air Passengers

```{r}
class(AirPassengers)
str(AirPassengers)
AirPassengers
```

#### Convert ts to xts

Converting to an xts object can often make the data more intuitive to deal with.

```{r}
Nile_xts <- as.xts(Nile)
str(Nile_xts)
head(Nile_xts)
```

```{r}
Air_xts <- as.xts(AirPassengers)
str(Air_xts)
head(Air_xts)
```

Some types of data are already identified as being time series. For example, the quantmod package fetches stock market data as time series automatically:

```{r}
## use quantmod pkg to get some stock prices as time series
price <- getSymbols(Symbols='EA', from="2020-01-01", to=Sys.Date(), auto.assign=FALSE)
head(price)
```

A key characteristic of time series object is that dates are row numbers rather than being in a date column, as they would be in typical data frame. Looking at the structure of the xts object, we can see it is different from a data frame.

```{r}
str(price)
```

#### Convert xts to data frame

If you want to work with the time series as a data frame, it is fairly straightforward to convert an xts object:

```{r}
price_df <- as.data.frame(price)
## add Date field based on index (row names) of xts object
price_df$Date <- index(price)
## set data frame row names to numbers instead of dates
rownames(price_df) <- seq(1:nrow(price))
## reorder columns to put Date first
price_df <- price_df %>% select(Date, 1:ncol(price_df)-1)
## check out structure using glimpse, as is the fashion of the times
glimpse(price_df)
```

Data frame is basically a straight-up table, whereas the xts object has other structural features. 

#### Convert data frame to xts

```{r}
## convert data frame to xts object by specifying the date field to use for xts index.
price_xts <- xts(price_df, order.by=as.Date(price_df_im$Date))
str(price_xts)
```

Notice, however, that in the process of converting an xts object to data frame and back to xts, the xts Attributes information has been lost.

### Time Series Strengths

The structure of a time series leads a variety of advantages related to time-based analysis. A few of the main ones, at least from my perspective:

* Periodicity: can easily change from granular periods, such as daily, to aggregated periods.
* Period calculations: counting number of periods in the data (months, quarters, years).
* Selection/subsetting based on date ranges.
* Visualization: a number of visualization options are designed to work with time series. 
* Forecasting: time series objects are designed for applying various forecasting methods like Holt-Winters and ARIMA. This is well beyond the scope of this post, but we'll touch on it briefly.

#### Periodicity Manipulation

Change the period granularity to less granular:

```{r}
head(to.weekly(price)[,1:5])
head(to.monthly(price)[1:4,1:5])
head(to.yearly(price)[,1:5])
```

#### Period Counts

```{r}
## get the number of weeks, months, years in the dataset (including partial)
price_nw <- nweeks(price)
price_nm <- nmonths(price)
price_ny <- nyears(price)
```

The price data covers:

* `r nrow(price)` days
* `r price_nw` weeks
* `r price_nm` months
* `r price_ny` years (or *portions* thereof)

First/last dates:

```{r}
## get earliest date
st_date <- start(price)
## get last date
end_date <- end(price)
```

* Start: `r st_date`
* End: `r end_date`

#### Selecting/Subsetting

Time series objects make it easy to slice the data by date ranges. This is an area where time series *really* shine compared to trying to do the same thing with a data frame.

* xts does a good job at interpreting date ranges based on minimal info.
* '/' is a key symbol for separating dates.
* date ranges are inclusive of references used.

Note that in the following examples based on stock market data, some dates are missing when markets were closed.

```{r}
## subset on a YEAR (showing head and tail to confirm data is 2021 only)
head(price["2021"])
tail(price["2021"])

## get data DURING selected month
price["2020-02"]

## get data FROM start of a year to END OF SPECIFIC MONTH
price_jf <- price["2021/2021-02"]
head(price_jf, 4)
tail(price_jf, 3)

## get everything BEFORE specified date (based on what is avaliable)
price["/2020-01-06"]

## get everything BETWEEN two dates
price["2021-06-01/2021-06-04"]

## get everything AFTER specified date
price["2022-01-18/"]
```

#### Period Calculations

* simple arithmetic between two dates is not as straightforward as might be expected, but still easily doable.

```{r}
## subtraction of a given metric between two dates
as.numeric(price$EA.Close["2022-01-21"])-as.numeric(price$EA.Close["2022-01-18"])

## subtraction of one metric from another on same date
price$EA.Close["2022-01-18"]-price$EA.Open["2022-01-18"]
```

* lag.xts is versatile for lag calculations.

```{r}
## default is one period
head(price-lag.xts(price))
## set k for longer lag - this example starting at a date beyond the lag, so no NAs
head(price["2020-01-13/"]-lag.xts(price, k=7))

## works for individual column
price$EA.Close["2022-01-18/"]-lag.xts(price$EA.Close, k=2)
```

* diff for calculating differences, based on combination of lag and difference order.

```{r}
head(diff(price, lag=1, differences=1))
head(diff(price, lag=1, differences=2))
```

### Visualization

Time series objects offer some different visualization opportunities than data frames. Below are a couple of options.

#### Plot.ts

You can do a quick, simple plot with plot.ts(). Note that in this case the x-axis is the numerical index of the data point, and doesn't show the date. 

```{r}
plot.ts(price$EA.Close)
```

#### Dygraphs

The dygraphs package offers flexibility and interactivity for time series.

* easily show multiple metrics at once.
* scroll over to see details.
* select chart area to zoom in.

```{r}
dygraph(price[,1:4])
```


* subset for individual columns.
* easily add annotations for events.

```{r}
## use dyEvent to add annotations
graph <- dygraph(price$EA.Close)
graph <- dyEvent(graph, "2020-02-21","Start of Covid 19", labelLoc = 'top')
graph <- dyEvent(graph, "2021-06-10","New product announcements", labelLoc = 'top')
## print chart
graph
```


### Saving/Exporting time series data

This seems a bit tricky due to the structural name of time series objects. You can convert an xts object to data frame, export as csv, re-import, convert back to xts, as shown above. But, as we saw then, you can lose the xts Attribute info, which may be valuable. 

I couldn't actually find a good, simple solution.

### Forecasting

Time series objects are designed for forecasting exercises.




### Limitations

Times series objects are obviously a powerful way to work with time-based data. When doing statistical modeling or forecasting with time series, they are the go-to.

There are some cases where you may prefer to stick with data frames:

* **Export/Import**: data frames are easier to work with for importing and exporting. 
* **Multi-dimensional data**: time series work best when each row represents a distinct time. If you are dealing with multi-dimensional data, especially in tidy format, you may want to stick with data frame.
* **Visualization preferences**: if you are more comfortable with using ggplot2 (or other visualization tools geared toward data frames) a data frame may be preferable. Or if the document you are producing has ggplot2 charts, you may want to maintain standard presentation.
* **Forecasting needs**: if you are doing time series forecasting you will want to use a time series object. If you're not doing forecasting, there is less of a need. Limitation is that time-series forecasting is based only on historical trends in the data and doesn't include things like correlation with other factors.